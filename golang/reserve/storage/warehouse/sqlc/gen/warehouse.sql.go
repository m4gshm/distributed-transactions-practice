// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: warehouse.sql

package gen

import (
	"context"
)

const decrementAmountAndReserved = `-- name: DecrementAmountAndReserved :exec
UPDATE
  warehouse_item
SET
  amount = amount - $2,
  reserved = reserved - $2
WHERE
  id = $1
`

type DecrementAmountAndReservedParams struct {
	ID     string
	Amount int32
}

func (q *Queries) DecrementAmountAndReserved(ctx context.Context, arg DecrementAmountAndReservedParams) error {
	_, err := q.db.Exec(ctx, decrementAmountAndReserved, arg.ID, arg.Amount)
	return err
}

const decrementReserved = `-- name: DecrementReserved :exec
UPDATE
  warehouse_item
SET
  reserved = reserved - $2
WHERE
  id = $1
`

type DecrementReservedParams struct {
	ID       string
	Reserved int32
}

func (q *Queries) DecrementReserved(ctx context.Context, arg DecrementReservedParams) error {
	_, err := q.db.Exec(ctx, decrementReserved, arg.ID, arg.Reserved)
	return err
}

const incrementReserved = `-- name: IncrementReserved :exec
UPDATE
  warehouse_item
SET
  reserved = reserved + $2
WHERE
  id = $1
`

type IncrementReservedParams struct {
	ID       string
	Reserved int32
}

func (q *Queries) IncrementReserved(ctx context.Context, arg IncrementReservedParams) error {
	_, err := q.db.Exec(ctx, incrementReserved, arg.ID, arg.Reserved)
	return err
}

const selectAllItems = `-- name: SelectAllItems :many
SELECT
  id, amount, reserved, unit_cost, updated_at
FROM
  warehouse_item
`

func (q *Queries) SelectAllItems(ctx context.Context) ([]WarehouseItem, error) {
	rows, err := q.db.Query(ctx, selectAllItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WarehouseItem
	for rows.Next() {
		var i WarehouseItem
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.Reserved,
			&i.UnitCost,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectItemByID = `-- name: SelectItemByID :one
SELECT
  id, amount, reserved, unit_cost, updated_at
FROM
  warehouse_item
WHERE
  id = $1
`

func (q *Queries) SelectItemByID(ctx context.Context, id string) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, selectItemByID, id)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Reserved,
		&i.UnitCost,
		&i.UpdatedAt,
	)
	return i, err
}

const selectItemByIDForUpdate = `-- name: SelectItemByIDForUpdate :one
SELECT
  id, amount, reserved, unit_cost, updated_at
FROM
  warehouse_item
WHERE
  id = $1 FOR
UPDATE
`

func (q *Queries) SelectItemByIDForUpdate(ctx context.Context, id string) (WarehouseItem, error) {
	row := q.db.QueryRow(ctx, selectItemByIDForUpdate, id)
	var i WarehouseItem
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.Reserved,
		&i.UnitCost,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAmountAndReserved = `-- name: UpdateAmountAndReserved :exec
UPDATE
  warehouse_item
SET
  amount = COALESCE($2, amount),
  reserved = COALESCE($3, reserved)
WHERE
  id = $1
`

type UpdateAmountAndReservedParams struct {
	ID       string
	Amount   int32
	Reserved int32
}

func (q *Queries) UpdateAmountAndReserved(ctx context.Context, arg UpdateAmountAndReservedParams) error {
	_, err := q.db.Exec(ctx, updateAmountAndReserved, arg.ID, arg.Amount, arg.Reserved)
	return err
}
