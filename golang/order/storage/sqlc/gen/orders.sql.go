// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteItemsByOrderId = `-- name: DeleteItemsByOrderId :exec
DELETE FROM
  item
WHERE
  order_id = $1
`

func (q *Queries) DeleteItemsByOrderId(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, deleteItemsByOrderId, orderID)
	return err
}

const findAllOrders = `-- name: FindAllOrders :many
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
`

type FindAllOrdersRow struct {
	Order    Order
	Delivery Delivery
}

func (q *Queries) FindAllOrders(ctx context.Context) ([]FindAllOrdersRow, error) {
	rows, err := q.db.Query(ctx, findAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllOrdersRow
	for rows.Next() {
		var i FindAllOrdersRow
		if err := rows.Scan(
			&i.Order.ID,
			&i.Order.CreatedAt,
			&i.Order.UpdatedAt,
			&i.Order.Status,
			&i.Order.CustomerID,
			&i.Order.ReserveID,
			&i.Order.PaymentID,
			&i.Order.PaymentTransactionID,
			&i.Order.ReserveTransactionID,
			&i.Delivery.OrderID,
			&i.Delivery.Address,
			&i.Delivery.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findItemsByOrderId = `-- name: FindItemsByOrderId :many
SELECT
  id, order_id, amount
FROM
  item i
WHERE
  i.order_id = $1
`

func (q *Queries) FindItemsByOrderId(ctx context.Context, orderID string) ([]Item, error) {
	rows, err := q.db.Query(ctx, findItemsByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(&i.ID, &i.OrderID, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrderById = `-- name: FindOrderById :one
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
WHERE
  o.id = $1
`

type FindOrderByIdRow struct {
	Order    Order
	Delivery Delivery
}

func (q *Queries) FindOrderById(ctx context.Context, id string) (FindOrderByIdRow, error) {
	row := q.db.QueryRow(ctx, findOrderById, id)
	var i FindOrderByIdRow
	err := row.Scan(
		&i.Order.ID,
		&i.Order.CreatedAt,
		&i.Order.UpdatedAt,
		&i.Order.Status,
		&i.Order.CustomerID,
		&i.Order.ReserveID,
		&i.Order.PaymentID,
		&i.Order.PaymentTransactionID,
		&i.Order.ReserveTransactionID,
		&i.Delivery.OrderID,
		&i.Delivery.Address,
		&i.Delivery.Type,
	)
	return i, err
}

const findOrdersByClientAndStatuses = `-- name: FindOrdersByClientAndStatuses :many
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
WHERE
  o.customer_id = $1
  AND o.status = ANY($2::order_status[])
`

type FindOrdersByClientAndStatusesParams struct {
	CustomerID  string
	Orderstatus []OrderStatus
}

type FindOrdersByClientAndStatusesRow struct {
	Order    Order
	Delivery Delivery
}

func (q *Queries) FindOrdersByClientAndStatuses(ctx context.Context, arg FindOrdersByClientAndStatusesParams) ([]FindOrdersByClientAndStatusesRow, error) {
	rows, err := q.db.Query(ctx, findOrdersByClientAndStatuses, arg.CustomerID, arg.Orderstatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOrdersByClientAndStatusesRow
	for rows.Next() {
		var i FindOrdersByClientAndStatusesRow
		if err := rows.Scan(
			&i.Order.ID,
			&i.Order.CreatedAt,
			&i.Order.UpdatedAt,
			&i.Order.Status,
			&i.Order.CustomerID,
			&i.Order.ReserveID,
			&i.Order.PaymentID,
			&i.Order.PaymentTransactionID,
			&i.Order.ReserveTransactionID,
			&i.Delivery.OrderID,
			&i.Delivery.Address,
			&i.Delivery.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateDelivery = `-- name: InsertOrUpdateDelivery :exec
INSERT INTO
  delivery (order_id, address, type)
VALUES
  ($1, $2, $3) ON CONFLICT(order_id) DO
UPDATE
SET
  address = EXCLUDED.address,
  type = EXCLUDED.type
`

type InsertOrUpdateDeliveryParams struct {
	OrderID string
	Address string
	Type    DeliveryType
}

func (q *Queries) InsertOrUpdateDelivery(ctx context.Context, arg InsertOrUpdateDeliveryParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateDelivery, arg.OrderID, arg.Address, arg.Type)
	return err
}

const insertOrUpdateItem = `-- name: InsertOrUpdateItem :exec
INSERT INTO
  item (order_id, id, amount)
VALUES
  ($1, $2, $3) ON CONFLICT(order_id, id) DO
UPDATE
SET
  amount = EXCLUDED.amount
`

type InsertOrUpdateItemParams struct {
	OrderID string
	ID      string
	Amount  int32
}

func (q *Queries) InsertOrUpdateItem(ctx context.Context, arg InsertOrUpdateItemParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateItem, arg.OrderID, arg.ID, arg.Amount)
	return err
}

const insertOrUpdateOrder = `-- name: InsertOrUpdateOrder :exec
INSERT INTO
  orders (
    id,
    status,
    created_at,
    updated_at,
    customer_id,
    reserve_id,
    payment_id,
    payment_transaction_id,
    reserve_transaction_id
  )
VALUES
  ($1, $2, $3, $4, $5, $6, $7, $8, $9) ON CONFLICT(id) DO
UPDATE
SET
  status = EXCLUDED.status,
  updated_at = EXCLUDED.updated_at,
  reserve_id = COALESCE(EXCLUDED.reserve_id, orders.reserve_id),
  payment_id = COALESCE(EXCLUDED.payment_id, orders.payment_id)
`

type InsertOrUpdateOrderParams struct {
	ID                   string
	Status               OrderStatus
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	CustomerID           string
	ReserveID            pgtype.Text
	PaymentID            pgtype.Text
	PaymentTransactionID pgtype.Text
	ReserveTransactionID pgtype.Text
}

func (q *Queries) InsertOrUpdateOrder(ctx context.Context, arg InsertOrUpdateOrderParams) error {
	_, err := q.db.Exec(ctx, insertOrUpdateOrder,
		arg.ID,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CustomerID,
		arg.ReserveID,
		arg.PaymentID,
		arg.PaymentTransactionID,
		arg.ReserveTransactionID,
	)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE
  orders
SET
  status = $1,
  updated_at = COALESCE($2, CURRENT_TIMESTAMP)
`

type UpdateOrderStatusParams struct {
	Status    OrderStatus
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.Status, arg.UpdatedAt)
	return err
}
