// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAmount = `-- name: AddAmount :one
UPDATE account
SET amount = amount + $2,
    updated_at = NOW()
WHERE client_id = $1
RETURNING amount,
    locked,
    updated_at
`

type AddAmountParams struct {
	ClientID string
	Amount   float64
}

type AddAmountRow struct {
	Amount    float64
	Locked    float64
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) AddAmount(ctx context.Context, arg AddAmountParams) (AddAmountRow, error) {
	row := q.db.QueryRow(ctx, addAmount, arg.ClientID, arg.Amount)
	var i AddAmountRow
	err := row.Scan(&i.Amount, &i.Locked, &i.UpdatedAt)
	return i, err
}

const addLock = `-- name: AddLock :one
UPDATE account
SET locked = locked + $2,
    updated_at = NOW()
WHERE client_id = $1
RETURNING amount,
    locked,
    updated_at
`

type AddLockParams struct {
	ClientID string
	Locked   float64
}

type AddLockRow struct {
	Amount    float64
	Locked    float64
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) AddLock(ctx context.Context, arg AddLockParams) (AddLockRow, error) {
	row := q.db.QueryRow(ctx, addLock, arg.ClientID, arg.Locked)
	var i AddLockRow
	err := row.Scan(&i.Amount, &i.Locked, &i.UpdatedAt)
	return i, err
}

const findAccountById = `-- name: FindAccountById :one
SELECT client_id, amount, locked, updated_at
FROM account
WHERE client_id = $1
`

func (q *Queries) FindAccountById(ctx context.Context, clientID string) (Account, error) {
	row := q.db.QueryRow(ctx, findAccountById, clientID)
	var i Account
	err := row.Scan(
		&i.ClientID,
		&i.Amount,
		&i.Locked,
		&i.UpdatedAt,
	)
	return i, err
}

const findAccountByIdForUpdate = `-- name: FindAccountByIdForUpdate :one
SELECT client_id, amount, locked, updated_at
FROM account
WHERE client_id = $1 FOR UPDATE
`

func (q *Queries) FindAccountByIdForUpdate(ctx context.Context, clientID string) (Account, error) {
	row := q.db.QueryRow(ctx, findAccountByIdForUpdate, clientID)
	var i Account
	err := row.Scan(
		&i.ClientID,
		&i.Amount,
		&i.Locked,
		&i.UpdatedAt,
	)
	return i, err
}

const findAllAccounts = `-- name: FindAllAccounts :many
SELECT client_id, amount, locked, updated_at
FROM account
`

func (q *Queries) FindAllAccounts(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, findAllAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ClientID,
			&i.Amount,
			&i.Locked,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlock = `-- name: Unlock :one
UPDATE account
SET locked = locked - $2,
    updated_at = NOW()
WHERE client_id = $1
RETURNING amount,
    locked,
    updated_at
`

type UnlockParams struct {
	ClientID string
	Locked   float64
}

type UnlockRow struct {
	Amount    float64
	Locked    float64
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) Unlock(ctx context.Context, arg UnlockParams) (UnlockRow, error) {
	row := q.db.QueryRow(ctx, unlock, arg.ClientID, arg.Locked)
	var i UnlockRow
	err := row.Scan(&i.Amount, &i.Locked, &i.UpdatedAt)
	return i, err
}

const writeOff = `-- name: WriteOff :one
UPDATE account
SET amount = amount - $2,
    locked = locked - $2,
    updated_at = NOW()
WHERE client_id = $1
RETURNING amount,
    locked,
    updated_at
`

type WriteOffParams struct {
	ClientID string
	Amount   float64
}

type WriteOffRow struct {
	Amount    float64
	Locked    float64
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) WriteOff(ctx context.Context, arg WriteOffParams) (WriteOffRow, error) {
	row := q.db.QueryRow(ctx, writeOff, arg.ClientID, arg.Amount)
	var i WriteOffRow
	err := row.Scan(&i.Amount, &i.Locked, &i.UpdatedAt)
	return i, err
}
