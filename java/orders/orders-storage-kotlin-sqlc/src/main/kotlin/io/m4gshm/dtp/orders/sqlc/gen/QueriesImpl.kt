// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package io.m4gshm.dtp.orders.sqlc.gen

import io.m4gshm.dtp.orders.sqlc.getDelivery
import io.m4gshm.dtp.orders.sqlc.getOrder
import java.sql.Connection
import java.sql.SQLException
import java.sql.Types
import java.time.OffsetDateTime

const val deleteItemsByOrderId = """-- name: deleteItemsByOrderId :exec
DELETE FROM
  item
WHERE
  order_id = ?
"""

const val findAllOrders = """-- name: findAllOrders :many
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
"""

data class FindAllOrdersRow(
    val orders: Order?,
    val delivery: Delivery?
)

const val findItemsByOrderId = """-- name: findItemsByOrderId :many
SELECT
  id, order_id, amount
FROM
  item i
WHERE
  i.order_id = ?
"""

const val findOrderById = """-- name: findOrderById :one
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
WHERE
  o.id = ?
"""

data class FindOrderByIdRow(
    val orders: Order?,
    val delivery: Delivery?
)

const val findOrdersByClientAndStatuses = """-- name: findOrdersByClientAndStatuses :many
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
WHERE
  o.customer_id = ?
  AND o.status = ANY(?::order_status[])
"""

data class FindOrdersByClientAndStatusesRow(
    val orders: Order?,
    val delivery: Delivery?
)

const val findOrdersPaged = """-- name: findOrdersPaged :many
SELECT
  o.id, o.created_at, o.updated_at, o.status, o.customer_id, o.reserve_id, o.payment_id, o.payment_transaction_id, o.reserve_transaction_id,
  d.order_id, d.address, d.type
FROM
  orders o
  LEFT JOIN delivery d ON o.id = d.order_id
  WHERE  (?::order_status IS NULL OR o.status = ?::order_status)
  ORDER BY o.created_at
  LIMIT ?::int
  OFFSET ?::int
"""

data class FindOrdersPagedRow(
    val orders: Order?,
    val delivery: Delivery?
)

const val insertOrUpdateDelivery = """-- name: insertOrUpdateDelivery :exec
INSERT INTO
  delivery (order_id, address, type)
VALUES
  (?, ?, ?) ON CONFLICT(order_id) DO
UPDATE
SET
  address = EXCLUDED.address,
  type = EXCLUDED.type
"""

const val insertOrUpdateItem = """-- name: insertOrUpdateItem :exec
INSERT INTO
  item (order_id, id, amount)
VALUES
  (?, ?, ?) ON CONFLICT(id, order_id) DO
UPDATE
SET
  amount = EXCLUDED.amount
"""

const val insertOrUpdateOrder = """-- name: insertOrUpdateOrder :exec
INSERT INTO
  orders (
    id,
    status,
    created_at,
    customer_id,
    reserve_id,
    payment_id,
    payment_transaction_id,
    reserve_transaction_id
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(id) DO
UPDATE
SET
  "status" = EXCLUDED.status,
  reserve_id = COALESCE(EXCLUDED.reserve_id, orders.reserve_id),
  payment_id = COALESCE(EXCLUDED.payment_id, orders.payment_id),
  updated_at = COALESCE(?, CURRENT_TIMESTAMP)
"""

const val updateOrderStatus = """-- name: updateOrderStatus :exec
UPDATE
  orders
SET
  status = ?,
  updated_at = COALESCE(?, CURRENT_TIMESTAMP)
WHERE id = ?
"""

class QueriesImpl(private val conn: Connection) : Queries {

    @Throws(SQLException::class)
    override fun deleteItemsByOrderId(orderId: String) {
        conn.prepareStatement(deleteItemsByOrderId).use { stmt ->
            stmt.setString(1, orderId)

            stmt.execute()
        }
    }

    @Throws(SQLException::class)
    override fun findAllOrders(): List<FindAllOrdersRow> {
        return conn.prepareStatement(findAllOrders).use { stmt ->

            val results = stmt.executeQuery()
            val ret = mutableListOf<FindAllOrdersRow>()
            while (results.next()) {

                ret.add(
                    FindAllOrdersRow(
                        results.getOrder(),
                        results.getDelivery()
                    )
                )
            }
            ret
        }
    }

    @Throws(SQLException::class)
    override fun findItemsByOrderId(orderId: String): List<Item> {
        return conn.prepareStatement(findItemsByOrderId).use { stmt ->
            stmt.setString(1, orderId)

            val results = stmt.executeQuery()
            val ret = mutableListOf<Item>()
            while (results.next()) {
                ret.add(
                    Item(
                        results.getString(1),
                        results.getString(2),
                        results.getInt(3)
                    )
                )
            }
            ret
        }
    }

    @Throws(SQLException::class)
    override fun findOrderById(id: String): FindOrderByIdRow? {
        return conn.prepareStatement(findOrderById).use { stmt ->
            stmt.setString(1, id)

            val results = stmt.executeQuery()
            if (!results.next()) {
                return null
            }
            val ret = FindOrderByIdRow(
                results.getOrder(),
                results.getDelivery()
            )
            if (results.next()) {
                throw SQLException("expected one row in result set, but got many")
            }
            ret
        }
    }

    @Throws(SQLException::class)
    override fun findOrdersByClientAndStatuses(
        customerId: String,
        orderstatus: List<OrderStatus>
    ): List<FindOrdersByClientAndStatusesRow> {
        return conn.prepareStatement(findOrdersByClientAndStatuses).use { stmt ->
            stmt.setString(1, customerId)
            stmt.setArray(2, conn.createArrayOf("order_status", orderstatus.map { v -> v.value }.toTypedArray()))

            val results = stmt.executeQuery()
            val ret = mutableListOf<FindOrdersByClientAndStatusesRow>()
            while (results.next()) {
                ret.add(
                    FindOrdersByClientAndStatusesRow(
                        results.getOrder(),
                        results.getDelivery()
                    )
                )
            }
            ret
        }
    }

    @Throws(SQLException::class)
    override fun findOrdersPaged(
        status: OrderStatus?,
        lim: Int?,
        offs: Int
    ): List<FindOrdersPagedRow> {
        return conn.prepareStatement(findOrdersPaged).use { stmt ->
            val statusValue = status?.value
            stmt.setObject(1, statusValue, Types.OTHER)
            stmt.setObject(2, statusValue, Types.OTHER)
            stmt.setInt(3, lim!!)
            stmt.setInt(4, offs)

            val results = stmt.executeQuery()
            val ret = mutableListOf<FindOrdersPagedRow>()
            while (results.next()) {
                ret.add(
                    FindOrdersPagedRow(
                        results.getOrder(),
                        results.getDelivery()
                    )
                )
            }
            ret
        }
    }

    @Throws(SQLException::class)
    override fun insertOrUpdateDelivery(
        orderId: String,
        address: String,
        type: DeliveryType
    ) {
        conn.prepareStatement(insertOrUpdateDelivery).use { stmt ->
            stmt.setString(1, orderId)
            stmt.setString(2, address)
            stmt.setObject(3, type.value, Types.OTHER)

            stmt.execute()
        }
    }

    @Throws(SQLException::class)
    override fun insertOrUpdateItem(
        orderId: String,
        id: String,
        amount: Int
    ) {
        conn.prepareStatement(insertOrUpdateItem).use { stmt ->
            stmt.setString(1, orderId)
            stmt.setString(2, id)
            stmt.setInt(3, amount)

            stmt.execute()
        }
    }

    @Throws(SQLException::class)
    override fun insertOrUpdateOrder(
        id: String,
        status: OrderStatus,
        createdAt: OffsetDateTime,
        customerId: String,
        updatedAt: OffsetDateTime?,
        reserveId: String?,
        paymentId: String?,
        paymentTransactionId: String?,
        reserveTransactionId: String?
    ) {
        conn.prepareStatement(insertOrUpdateOrder).use { stmt ->
            stmt.setString(1, id)
            stmt.setObject(2, status.value, Types.OTHER)
            stmt.setObject(3, createdAt)
            stmt.setString(4, customerId)
            stmt.setString(5, reserveId)
            stmt.setString(6, paymentId)
            stmt.setString(7, paymentTransactionId)
            stmt.setString(8, reserveTransactionId)
            stmt.setObject(9, updatedAt)

            stmt.execute()
        }
    }

    @Throws(SQLException::class)
    override fun updateOrderStatus(
        status: OrderStatus,
        updatedAt: OffsetDateTime?,
        id: String
    ) {
        conn.prepareStatement(updateOrderStatus).use { stmt ->
            stmt.setObject(1, status.value, Types.OTHER)
            stmt.setObject(2, updatedAt)
            stmt.setString(3, id)

            stmt.execute()
        }
    }
}
